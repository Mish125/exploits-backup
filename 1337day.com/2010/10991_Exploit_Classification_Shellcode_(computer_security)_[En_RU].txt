======================================================
Exploit Classification / Shellcode (computer security)
======================================================

1-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=0                          
0     _                   __           __       __                     1
1   /' \            __  /'__`\        /\ \__  /'__`\                   0
0  /\_, \    ___   /\_\/\_\ \ \    ___\ \ ,_\/\ \/\ \  _ ___           1
1  \/_/\ \ /' _ `\ \/\ \/_/_\_<_  /'___\ \ \/\ \ \ \ \/\`'__\          0
0     \ \ \/\ \/\ \ \ \ \/\ \ \ \/\ \__/\ \ \_\ \ \_\ \ \ \/           1
1      \ \_\ \_\ \_\_\ \ \ \____/\ \____\\ \__\\ \____/\ \_\           0
0       \/_/\/_/\/_/\ \_\ \/___/  \/____/ \/__/ \/___/  \/_/           1
1                  \ \____/ >> Exploit database separated by exploit   0
0                   \/___/          type (local, remote, DoS, etc.)    1
1                                                                      0
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-1

#[+] Discovered By   : Inj3ct0r
#[+] Site            : Inj3ct0r.com
#[+] support e-mail  : submit[at]inj3ct0r.com

о----------------[0x01]---> EXPLOIT ;
о----------------[0x02]---> Shellcode ;
                                         // English description, review / Russia описание , обзор 

// English

[0x01] - EXPLOIT

An exploit (from the same word in the French language, meaning "achievement", or "accomplishment") 

is a piece of software, a chunk of data, or sequence of commands that take advantage of a bug, 

glitch or vulnerability in order to cause unintended or unanticipated behavior to occur on computer software, 

hardware, or something electronic (usually computerised). This frequently includes such things as gaining 

control of a computer system or allowing privilege escalation or a denial of service attack.

-----------------------
[=>] Classification
-----------------------

There are several methods of classifying exploits. The most common is by how the exploit contacts the vulnerable software. 

A 'remote exploit' works over a network and exploits the security vulnerability without any prior access to the vulnerable system. 

A 'local exploit' requires prior access to the vulnerable system and usually increases the privileges of the person running the exploit past those granted by the system administrator. 

Exploits against client applications also exist, usually consisting of modified servers that send an exploit if accessed with client application. 

Exploits against client applications may also require some interaction with the user and thus may be used in combination with social engineering method.

Another classification is by the action against vulnerable system: unauthorized data access, arbitrary code execution, denial of service.

Many exploits are designed to provide superuser-level access to a computer system. However, it is also possible to use several exploits, first to gain low-level access, 

then to escalate privileges repeatedly until one reaches root.

Normally a single exploit can only take advantage of a specific software vulnerability. Often, when an exploit is published, the vulnerability is fixed through a patch and the exploit becomes obsolete for newer versions of the software. 

This is the reason why some blackhat hackers do not publish their exploits but keep them private to themselves or other crackers. 

Such exploits are referred to as 'zero day exploits' and to obtain access to such exploits is the primary desire of unskilled attackers, often nicknamed script kiddies.

-----------------------
[=>] Types of exploit
-----------------------

Exploits are commonly categorized and named by these criteria:

    * The type of vulnerability they exploit.
    * Whether they need to be run on the same machine as the program that has the vulnerability (local) or can be run on one machine to attack a program running on another machine (remote).
    * The result of running the exploit (EoP, DoS, Spoofing, etc...)



[0x02] - SHELLCODE

In computer security, a shellcode is a small piece of code used as the payload in the exploitation of a software vulnerability. 

It is called "shellcode" because it typically starts a command shell from which the attacker can control the compromised machine. 

Shellcode is commonly written in machine code, but any piece of code that performs a similar task can be called shellcode. 

Because the function of a payload is not limited to merely spawning a shell, some have suggested that the name shellcode is insufficient.

However, attempts at replacing the term have not gained wide acceptance.

-----------------------
[=>] Types of shellcode
-----------------------

Shellcode can either be "local" or "remote", depending on whether it gives an attacker control over the same machine as it runs on (local) or over another machine through a network (remote). 

In some situations when it is hard to inject and execute a shellcode with the desired functionality directly, "staged" shellcode may be used.
-----------------------
[=>] Local shellcode
-----------------------


A local shellcode is used by an attacker who has limited access to a machine but can exploit a vulnerability in a process on that machine that has higher privileges. 

If successfully executed, the shellcode will provide the attacker access to the machine with the same higher privileges as the targeted process. 

Local shellcode is relatively easy to create; often the only thing it does is execute a shell executable.

-----------------------
[=>] Remote shellcode
-----------------------


A remote shellcode is used when an attacker wants to target a vulnerable process running on another machine on the local network or internet. 

If successfully executed, the shellcode can provide the attacker access to the target machine across the network. 

Remote shellcodes normally use standard TCP/IP socket connections to allow the attacker access to the shell on the target machine. 

Such shellcode can be sub-divided based on how this connection is set up: if the shellcode can establish this connection, it is called connect-back shellcode 

because the shellcode connects back to the attacker's machine. On the other hand, if the attacker needs to create the connection, 

the shellcode is called a bindshell because the shellcode binds to a certain port on which the attacker can connect to control it. 

A third, much less common type is socket-reuse shellcode. This type of shellcode is sometimes used when an exploit establishes a connection to the vulnerable 

process that is not closed before the shellcode is run. The shellcode can then re-use this connection to communicate with the attacker. 

Socket re-using shellcode is harder to create because the shellcode needs to find out which connection to re-use and the machine may have many connections open.

A firewall can be used to detect the outgoing connections made by connect-back shellcodes and the attempt to accept incoming connections made by bindshells. 

They can therefore offer some protection against an attacker, even if the system is vulnerable, by preventing the attacker from gaining access to the shell created by the shellcode. 

This is one reason why socket re-using shellcode is sometimes used: because it does not create new connections and therefore is harder to detect and block.

-----------------------------------
[=>] Download and execute shellcode
-----------------------------------


This is a type of remote shellcode that downloads and executes some form of malware on the target system. This type of shellcode does not spawn a shell, 

but rather instructs the machine to download a certain executable file off the network, save it to disk and execute it. 

Nowadays, it is commonly used in drive-by download attacks, where a victim visits a malicious webpage that in turn attempts to run such a download and execute 

shellcode in order to install software on the victim's machine. A variation of this type of shellcode downloads and loads a library.

Benefits of this technique are that the code can be smaller, that it does not require the shellcode to spawn a new process on the target system and that the shellcode does not need 

code to "clean up" the targetted process (this can be done by the library loaded into the process.

---------------------
[=>] Staged shellcode
---------------------


When the amount of data that an attacker can inject into the target process is too limited to execute useful shellcode directly, it may be possible to execute it in stages. 

First, a small piece of shellcode (stage 1) is executed. This code then downloads a larger piece of shellcode (stage 2) into the process' memory and executes it.

-----------------------
[=>] Egg-hunt shellcode
-----------------------


Another form of staged shellcode, which is used if an attacker can inject a larger shellcode into the process, but cannot determine where in the process it will end up. 

A small egg-hunt shellcode is injected into the process at a predictable location and executed. This code then searches the process' address space for the larger shellcode (the egg) and executes it.

---------------------
[=>] Omelet shellcode
---------------------


This type of shellcode is similar to egg-hunt shellcode, but looks for multiple small blocks of data (eggs) and recombines them into one larger block (the omelet) that is subsequently executed. 

This is used when an attacker can only inject a number of small blocks of data into the process.

---------------------------------
[=>] Shellcode execution strategy
---------------------------------

An exploit will commonly inject a shellcode into the target process before or at the same time as it exploits a vulnerability to gain control over the program counter. 

The program counter is adjusted to point to the shellcode, after which it gets executed and performs its task. Injecting the shellcode is often done by storing 

the shellcode in data sent over the network to the vulnerable process, by supplying it in a file that is read by the vulnerable process or through the command line or environment in the case of local exploits.

Shellcode encoding

Because most processes filter or restrict the data that can be injected, shellcode often need to be written to allow for these restrictions, this includes making the code small, null-free or alphanumeric. 

Various solutions have been found to get around such restrictions, including:

    * Design and implementation optimizations to decrease the size of the shellcode.
    * Implementation modifications to get around limitations in the range of bytes used in the shellcode.
    * Self-modifying code that modifies a number of the bytes of its own code before executing them to re-create bytes that are normally impossible to inject into the process.

Since intrusion detection can detect signatures of simple shellcodes being sent over the network, it is often encoded, made self-decrypting or polymorphic to avoid detection.

Percentage encoding

Exploits that target browsers commonly encode shellcode in a JavaScript string using Percent-encoding, "\uXXXX"-encoding or entity encoding. Some exploits also obfuscate the encoded shellcode 

string further to prevent detection by IDS. For example, on the IA-32 architecture, here's how two NOP instructions would look, first unencoded:

90             NOP
90             NOP

Then encoded into a string using percent-encoding (using the unescape() function to decode):

unescape("%u9090");

Next encoded into a string using "\uXXXX"-encoding:

"\u9090";

And finally encoded into a string using entity encoding:

"&#x9090;"

or

"&#37008;"

------------------------
[=>] Null free shellcode
------------------------


Most shellcodes are written without the use of null bytes because they are intended to be injected into a target process through null-terminated strings. 

When a null-terminated string is copied, it will be copied up to and including the first null but subsequent bytes of the shellcode will not be processed. 

When shellcode that contains nulls is injected in this way, only part of the shellcode would be injected, making it very unlikely to run successfully.

To produce null free shellcode from shellcode that contains null bytes one can substitute machine instructions that contain zeroes with instructions that have the same effect but are free of nulls. For example, on the IA-32 architecture one could replace this instruction:

B8 01000000    MOV EAX,1          // Set the register EAX to 0x000000001

which contains zeroes as part of the literal (1 expands to 0x00000001) with these instructions:

33C0           XOR EAX,EAX        // Set the register EAX to 0x000000000
40             INC EAX            // Increase EAX to 0x00000001

which have the same effect but take fewer bytes to encode and are free of nulls.

-----------------------------------------
[=>] Alphanumeric and printable shellcode
-----------------------------------------

In certain circumstances, a target process will filter any byte from the injected shellcode that is not a printable or alphanumeric character. 

Under such circumstances, the range of instructions that can be used to write a shellcode becomes very limited. 

A solution to this problem was published by Rix in Phrack 57[6] in which he showed it was possible to turn any code into alphanumeric code. 

A technique often used is to create self-modifying code, because this allows the code to modify its own bytes to include bytes outside of the normally allowed range, 

thereby expanding the range of instructions it can use. Using this trick, a self-modifying decoder can be created that uses only bytes in the allowed range. The main code of the shellcode is encoded, 

also only using bytes in the allowed range. When the output shellcode is run, the decoder can modify its own code to be able to use any instruction it requires to function properly and then continues to decode the original shellcode. 

After decoding the shellcode the decoder transfers control to it, so it can be executed as normal. It has been shown that it is possible to create shellcode that looks like normal text in English.


----------------------------
[=>] Unicode proof shellcode
----------------------------


Modern programs use Unicode strings to allow internationalization of text. Often, these programs will convert incoming ASCII strings to Unicode before processing them. 

Unicode strings encoded in UTF-16 use two bytes to encode each character (or four bytes for some special characters). When an ASCII string is transformed into UTF-16, a zero byte is inserted after each byte in the original string. 

Obscou proved in Phrack 61 that it is possible to write shellcode that can run successfully after this transformation. Programs that can automatically encode any shellcode into alphanumeric UTF-16-proof shellcode exist, 

based on the same principle of a small self-modifying decoder that decodes the original shellcode.


--------------
[=>] Platforms
--------------

Most shellcode is written in machine code because of the low level at which the vulnerability being exploited gives an attacker access to the process. 

Shellcode is therefore often created to target one specific combination of processor, operating system and service pack, called a platform. 

For some exploits, due to the constraints put on the shellcode by the target process, a very specific shellcode must be created. 

However, it is not impossible for one shellcode to work for multiple exploits, service packs, operating systems and even processors.

Such versatility is commonly achieved by creating multiple versions of the shellcode that target the various platforms and creating a header that branches to the correct version for the platform 

the code is running on. When executed, the code behaves differently for different platforms and executes the right part of the shellcode for the platform it is running on.

// Russia

[0x01] - Эксплойт


Эксплойт, эксплоит (англ. exploit, эксплуатировать) — это компьютерная программа, фрагмент программного кода или последовательность команд, использующие уязвимости в программном обеспечении 
и применяемые для проведения атаки на вычислительную систему. Целью атаки может быть как захват контроля над системой (повышение привилегий), так и нарушение её функционирования (DoS-атака).

------------------
[=>] Классификация
------------------

В зависимости от метода получения доступа к уязвимому программному обеспечению, эксплоиты подразделяются на удалённые (англ. remote) и локальные (англ. local).

    * Удалённый эксплойт работает через сеть и использует уязвимость в защите без какого-либо предварительного доступа к уязвимой системе;
    * Локальный эксплойт запускается непосредственно в уязвимой системе, требуя предварительного доступа к ней. Обычно используется для получения взломщиком прав суперпользователя.

Атака эксплоита может быть нацелена на различные компоненты вычислительной системы — серверные приложения, клиентские приложения или модули операционной системы. Для использования серверной уязвимости эксплоиту достаточно сформировать и послать серверу запрос, содержащий вредоносный код. 

Использовать уязвимость клиента немного сложнее — требуется убедить пользователя в необходимости подключения к поддельному серверу (перехода по ссылке в случае если уязвимый клиент является браузером).

Эксплоит может распространяться в виде исходных текстов, исполняемых модулей, или словесного описания использования уязвимости. Он может быть написан на любом компилируемом или интерпретируемом языке программирования (наиболее частые: C/C++, Perl, PHP, HTML+JavaScript).

Эксплоиты могут быть классифицированы также по типу используемой ими уязвимости, такой как: переполнение буфера, SQL-инъекция, межсайтовый скриптинг, подделка межсайтовых запросов и т. д.

-----------------
[=>] Актуальность
-----------------


Информация, полученная в результате обнаружения уязвимости, может быть использована как для написания эксплоита, так и для устранения уязвимости. 

Поэтому в ней одинаково заинтересованы обе стороны — и взломщик и производитель. Характер распространения этой информации определяет время, которое требуется разработчику до выпуска заплатки.

После закрытия уязвимости производителем, шанс успешного применения эксплоита начинает стремительно уменьшаться. Поэтому особой популярностью среди хакеров пользуются так называемые 0-day эксплоиты, 

использующие недавно появившиеся уязвимости, которые еще не стали известны общественности

----------------------
[=>] Связки эксплоитов
----------------------

Связки эксплоитов представляют из себя пакет эксплоитов сразу под несколько программ (версий) и/или под разные уязвимости в них. В последних версиях связок производится выбор эксплоита именно под конкретную программу пользователя.

[0x02] - Шелл-Код

Код оболочки, шелл-код (англ. shellcode) — это двоичный исполняемый код, который обычно передаёт управление консоли, например '/bin/sh' Unix shell, command.com в MS-DOS и cmd.exe в операционных системах Microsoft Windows. 

Код оболочки может быть использован как полезная нагрузка эксплойта, обеспечивая взломщику доступ к командной оболочке (англ. shell) в компьютерной системе.

При эксплуатации удаленной уязвимости шелл-код может открывать заранее заданый порт TCP уязвимого компьютера, через который будет осуществляться дальнейший доступ к командной оболочке, такой код называется привязывающим к порту (англ. port binding shellcode).

Если шелл-код осуществляет подключение к порту компьютера атакующего, что производится с целью обхода брандмауэра или NAT, то такой код называется обратной оболочкой (англ. reverse shell shellcode).

-------------------
[=>] Принцип работы
-------------------


Шелл-код обычно внедряется в память эксплуатируемой программы, после чего на него передается управление путём переполнения стека, или при переполнении буфера в куче, или используя атаки форматной строки. 

Передача управления шелл-коду осуществляется перезаписью адреса возврата в стеке адресом внедрённого шелкода, перезаписью адресов вызываемых функций или изменением обработчиков прерываний. 

Результатом этого является выполнение шелл-кода, который открывает командную строку для использования взломщиком.

----------------
[=>] Обнаружение
----------------

Взломщики пишут шелл-коды часто используя приёмы, скрывающие их атаку. Они часто пытаются выяснить как системы обнаружения вторжений (СОВ) распознают любую входящую атаку. 

Типичная СОВ обычно просматривает все входящие пакеты в поисках структуры специфичной для шелл-кода (часто большой массив невыполняющихся кодов (NOP-ов)); если она находит такую структуру, пакет уничтожается до того, 

как он достигнет его целевого приложения. Слабая позиция СОВ в данном случае состоит в том, что она не осуществляет действительно хороший поиск иначе он займёт слишком много времени и таким образом замедлит соединение с интернетом.

Шелл-код почти всегда содержит строку с именем оболочки. Все входящие пакеты содержащие такую строку всегда рассматриваются как подозрительные в глазах СОВ. Также, некоторые приложения не принимают неалфавитно-цифровой ввод 

(они не принимают что-либо, кроме a-z, A-Z, 0-9, и несколько других символов.)

Для прохождения через все эти меры направленные против вторжения, взломщики используют шифрование, самомодифицирующийся код, полиморфный код и алфавитно-цифровой код.


# 1337day.com [2010-02-20]